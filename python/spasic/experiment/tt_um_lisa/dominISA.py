# SPDX-License-Identifier: Apache2.0
# Copyright (C) 2025 Ken Pettit

from spasic.experiment.experiment_parameters import ExperimentParameters
from spasic.experiment.experiment_result import ExpResult
from spasic.experiment.tt_um_lisa.lisa_controller import LisaController
from spasic.experiment.tt_um_lisa.opcode_writer import OpcodeWriter
from machine import Pin, UART
import time

# fmt: off
addr = 0
program = [
  0xA180, 0x0070, 0x8AC8, 0xA070, 0xA180, 0x0000, 0x8000, 0xA070, 0xF800, 0x9801, 0x8AD8, 0xAFFD, 0xA180, 0x0080, 0x8AC8, 0xA070,
  0xA180, 0x0070, 0x80A5, 0xA070, 0xF800, 0x9801, 0x8AD8, 0xAFFD, 0x97FF, 0xA180, 0x0000, 0x8000, 0x97FE, 0xA160, 0x8000, 0xFE01,
  0xA180, 0x0000, 0x8005, 0xF840, 0xF810, 0x8011, 0xF040, 0xC040, 0xA40A, 0xA210, 0x8001, 0x8000, 0xD804, 0xFC04, 0x80FF, 0xD040,
  0xA405, 0xA210, 0x8002, 0x8000, 0xD804, 0xFC04, 0x801E, 0xC840, 0xA419, 0xA210, 0x8004, 0x8000, 0xD804, 0xFC04, 0x8008, 0xC410,
  0xA428, 0xA210, 0x8008, 0x8000, 0xD804, 0xFC04, 0x8008, 0xC440, 0xA428, 0xA210, 0x8010, 0x8000, 0xD804, 0xFC04, 0xE410, 0xF440,
  0xF410, 0xA406, 0xA210, 0x8020, 0x8000, 0xD804, 0xFC04, 0x9C40, 0xF410, 0xF440, 0xA404, 0xA210, 0x8040, 0x8000, 0xD804, 0xFC04,
  0x8005, 0xA080, 0x97C0, 0xF600, 0x9440, 0xA0C0, 0xA405, 0xA210, 0x8080, 0x8000, 0xD804, 0xFC04, 0xA180, 0x0FE0, 0xA168, 0xA180,
  0x0000, 0xF47B, 0xA4E0, 0xA210, 0x8001, 0x8000, 0xD805, 0xFC05, 0xF47A, 0xD47F, 0xA40F, 0xA210, 0x8002, 0x8000, 0xD805, 0xFC05,
  0xA16C, 0xA180, 0x0000, 0xF841, 0x8010, 0xDC10, 0xA406, 0xA210, 0x8004, 0x8000, 0xD805, 0xFC05, 0xF040, 0xEC10, 0xA410, 0xA210,
  0x8008, 0x8000, 0xD805, 0xFC05, 0xF040, 0x8010, 0xD810, 0xA414, 0xA210, 0x8010, 0x8000, 0xD805, 0xFC05, 0x80FF, 0xF841, 0xE010,
  0xA4FB, 0xA210, 0x8020, 0x8000, 0xD805, 0xFC05, 0x80A5, 0xFC41, 0xE010, 0xD400, 0xF441, 0xA4A5, 0xA210, 0x8040, 0x8000, 0xD805,
  0xFC05, 0x80A5, 0xE841, 0xA210, 0x8080, 0x8000, 0xD805, 0xFC05, 0x97C0, 0x8002, 0xFA01, 0x8058, 0xEA41, 0xA170, 0x0001, 0x8AC0,
  0xA010, 0x8AC0, 0xA402, 0xA210, 0x8001, 0x8000, 0x9440, 0xA168, 0xA180, 0x0000, 0xD806, 0xFC06, 0xA16C, 0xA010, 0xA458, 0xA211,
  0x8000, 0x8002, 0xA180, 0x0000, 0xD806, 0xFC06, 0x97C0, 0x8002, 0xFA01, 0x8058, 0xA170, 0x0001, 0x800A, 0xA301, 0xA43C, 0xA211,
  0x8000, 0x8004, 0x9440, 0xA180, 0x0000, 0xD806, 0xFC06, 0x97C0, 0x8002, 0xFA01, 0x8059, 0xA170, 0x0001, 0x800A, 0xA311, 0xA401,
  0xA211, 0x8000, 0x8008, 0x9440, 0xA180, 0x0000, 0xD806, 0xFC06, 0x97C0, 0x8075, 0xFA03, 0x8001, 0xFA01, 0xF242, 0x8030, 0xA170,
  0x0003, 0xF242, 0x8090, 0xA300, 0x0001, 0xA44B, 0xA211, 0x8000, 0x8010, 0x9440, 0xA180, 0x0000, 0xD806, 0xFC06, 0x97C0, 0x8075,
  0xFA03, 0x8001, 0xFA01, 0xF242, 0x8032, 0xA170, 0x0003, 0xF242, 0x8090, 0xA310, 0x0001, 0xA402, 0xA211, 0x8000, 0x8020, 0x9440,
  0xA180, 0x0000, 0xD806, 0xFC06, 0xA180, 0x23F7, 0x97FE, 0xCE00, 0xF47A, 0xA4A3, 0xA210, 0x8040, 0x8000, 0xA180, 0x0000, 0xD806,
  0xFC06, 0xF479, 0xA4F7, 0xA210, 0x8080, 0x8000, 0xD806, 0xFC06, 0xCC00, 0x9402, 0x8AC0, 0xA180, 0x23F7, 0x8AD0, 0xA210, 0x8001,
  0x8000, 0xA180, 0x0000, 0xD807, 0xFC07, 0x80D0, 0xA1E2, 0x8040, 0xA1E3, 0xA1F0, 0x80CF, 0xA1E2, 0x8040, 0xA1E3, 0xA1F4, 0xA1E4,
  0xA1E0, 0xFC02, 0xA428, 0xA210, 0x8002, 0x8000, 0xA180, 0x0000, 0xD807, 0xFC07, 0xA1E1, 0xFC03, 0xA442, 0xA210, 0x8004, 0x8000,
  0xA180, 0x0000, 0xD807, 0xFC07, 0x8008, 0xA1E2, 0x8052, 0xA1E3, 0xA320, 0xA1E0, 0xFC20, 0xA4A4, 0xA210, 0x8008, 0x8000, 0xA180,
  0x0000, 0xD807, 0xFC07, 0xA1E1, 0xFC21, 0xA446, 0xA210, 0x8010, 0x8000, 0xA180, 0x0000, 0xD807, 0xFC07, 0x80A4, 0xA1E2, 0x8046,
  0xA1E3, 0xA1F1, 0x8083, 0xA1E2, 0x8045, 0xA1E3, 0xA1E9, 0xA1E0, 0xFC22, 0xA4C4, 0xA210, 0x8020, 0x8000, 0xA180, 0x0000, 0xD807,
  0xFC07, 0xA1E1, 0xFC23, 0xA446, 0xA210, 0x8040, 0x8000, 0xA180, 0x0000, 0xD807, 0xFC07, 0x8005, 0xFE14, 0x8010, 0xA070, 0xA070,
  0x804C, 0xFE12, 0xA070, 0xA070, 0xF613, 0xD402, 0xBFFE, 0x8049, 0xFE12, 0xF613, 0xD402, 0xBFFE, 0x8053, 0xFE12, 0xA070, 0xA070,
  0xF613, 0xD402, 0xBFFE, 0x8041, 0xFE12, 0xF613, 0xD402, 0xBFFE, 0x8000, 0xFE0C, 0x80F0, 0xFE08, 0x8055, 0xFE09, 0x807D, 0xFE0A,
  0x8001, 0xFE0C, 0x8000, 0xFE0D, 0xF60C, 0xD480, 0xBFFE, 0xE408, 0xF60C, 0xD480, 0xBFFE, 0xE408, 0xF60C, 0xD480, 0xBFFE, 0xE408,
  0xF60C, 0xD480, 0xBFFE, 0xE408, 0xA070, 0xA070, 0xD400, 0xBFC9,
]
# fmt: on

# Write more opcodes to the PIO FIFOs via the OpcodeWriter
def write_opcodes(op, count):
  global addr
  global program
  for i in range(0, count, 2):
    op.write(program[addr+i], program[addr+i+1])
  addr += count

# Send version request to set the UART baud, configure for SPI SRAM, etc.
def prepare_lisa(lisa, response):
  ver = lisa.get_ver()
  print(f'Debug ver: {ver}')
  if ver == 'lisav1.2':
      response.result[0] = 1 # version detected

  # Setup SPI RAM, Non-cashe SRAM, GPIO
  lisa.write_reg(0x17, 0x0010)
  lisa.write_reg(0x1b, 0x5456)
  lisa.write_reg(0x1c, 0x0001)
  lisa.write_reg(0x1d, 0x0007)
  lisa.write_reg(0x1e, 0x0800)

  # Validate we are talking to registers 
  r = lisa.read_reg(0x17)
  print(f'0x17 = 0x{r:04x}')
  if r == 0x10:
    response.result[0] |= 2 # SPI RAM mode enabled

# Report the progress of our test
def report_progress(lisa, response, brk, mode):
  ret = True
  pc = lisa.get_pc()
  sp = lisa.get_sp()
  ix = lisa.get_ix()
  a  = lisa.get_acc()
  d  = lisa.get_ram(4, 5)
  r  = response.result

  # Validate the brk location
  if brk != -1 and pc != brk:
    if r[1] == 0:
      r[1] = brk & 0xFF
      r[2] = pc & 0xFF
      r[0] |= (brk >> 2) & 0xC0
      r[0] |= (pc >> 4) & 0x30
      ret = False

  if mode == 1:
    print(f'PC: 0x{pc:04x}')
    print(f'    SP: 0x{sp:04x}  IX: 0x{ix:04x}  A: 0x{a:02x}  D: 0x{d[0]:02x} 0x{d[1]:02x} 0x{d[2]:02x} 0x{d[3]:02x} 0x{d[4]:02x}')
  else:
    r[3] = d[0]
    r[4] = d[1]
    r[5] = d[2]
    r[6] = d[3]
    r[7] = d[4]
    print(f'PC: 0x{pc:04x}  ', end='')
    print(f'response.result[] = 0x{r[0]:02x} 0x{r[1]:02x} 0x{r[2]:02x} 0x{r[3]:02x} 0x{r[4]:02x} 0x{r[5]:02x} 0x{r[6]:02x} 0x{r[7]:02x} 0x{r[8]:02x} 0x{r[9]:02x}')

  return ret

# ======================================================
# This is the main test entry
# ======================================================
def tickle_her_fancy(params: ExperimentParameters, response: ExpResult):
  global addr
  global toggle_count

  # Result is up to 10 bytes
  response.result = bytearray(10)
  mode = 0
  addr = 0

  # Enable LISA
  tt = params.tt
  tt.shuttle.tt_um_lisa.enable()
  tt.reset_project(True)
  tt.reset_project(False)

  op = OpcodeWriter()
  lisa = LisaController(tt)
  prepare_lisa(lisa, response)

  # Initialize UART1 using only RX pin
  uart1 = UART(1, baudrate=115200, rx=Pin(5))
  gpio4 = Pin(4, Pin.OUT)
  while uart1.any():
    c = uart1.read(1)

  # Validate LISA responding
  if response.result[0] != 3:
    print("Aborting test ... lisa not responding")
    return

  # Load the first 64 opcodes and do a couple of single
  # step operations.  Let's first validate we are doing
  # *something* prior to running.
  write_opcodes(op, 64)
  for i in range(4):
    # Step up to 4 times
    lisa.step()
    pc = lisa.get_pc()

    # If the PC reaches 2, then things are functional
    if pc == 2:
      response.result[0] |= 4
      ix = lisa.get_ix()

      # Test if the first opcode was successful
      if ix == 0x70:
        response.result[0] |= 8
      break

  # This array of Tuples runs the test.  The first
  # item is the number of opcodes to load from 'program'
  # to the PIO FIFOs.  The second number is the LISA PC
  # where a breakpoint must be set to prevent underflow
  # of the FIFos.  
  # fmt: off
  #       Load  Breakpoint
  flow = [(0,   0x03f),
          (56,  0x048),
          (8,   0x07e),
          (64,  0x0bf),
          (64,  0x0ff),
          (64,  0x13e),
          (64,  0x17f),
          (32,  0x19f),
          (56,  0x1d7),
         ]
  # fmt: on

  # Run the flow, loading opcodes and setting breakpoints
  # to check status and load more opcodes to the FIFOs
  addr = 64
  for load, brk in flow:
    if not params.keep_running:
      return

    # Load opcodes if needed
    if load > 0:
      write_opcodes(op, load)

    # Now set a breakpoint at 0x0d and see if we get there
    lisa.set_breakpoint(0, brk)
    lisa.cont(0.5)
    lisa.await_break(1.75)

    # Report progress and check for failure in breakpoint
    if not report_progress(lisa, response, brk, mode):
      return

  lisa.set_breakpoint(0, 0x1d7)
  for i in range(8):
    if not params.keep_running:
      break

    # Load opcodes from the main loop
    addr = 0x1A0
    write_opcodes(op, 56)

    # Now set a breakpoint at 0x0d and see if we get there
    lisa.step()
    lisa.cont(0.5)
    lisa.await_break(1.75)

    # Test for bytes from the UART
    line = b''
    while uart1.any():
      c = uart1.read(1)
      line += c
  
    if line == b'LISA':
      response.result[8] += 1
#      print(f'LISA RX: {line}')
  
    if not report_progress(lisa, response, 0x1d7, mode):
      break

  # If no error in breakpoints, report our 42 calculation
  if response.result[1] == 0 and response.result[2] == 0:
    d = lisa.get_ram(2, 2)
    response.result[1] = d[1]
    response.result[2] = d[0]
    response.result[9] = 1

  report_progress(lisa, response, -1, mode)

  lisa.dump_ram()

# vim: sw=2 ts=2 et

